diff --git a/consensus/replay.go b/consensus/replay.go
index 21fef6b2..1426cfe7 100644
--- a/consensus/replay.go
+++ b/consensus/replay.go
@@ -441,6 +441,7 @@ func (h *Handshaker) replayBlock(state sm.State, height int64, proxyApp proxy.Ap
 	meta := h.store.LoadBlockMeta(height)
 
 	blockExec := sm.NewBlockExecutor(h.stateDB, h.logger, proxyApp, sm.MockMempool{}, sm.MockEvidencePool{})
+	// XXX(yumin): setTxIndexer for cache is skipped.
 	blockExec.SetEventBus(h.eventBus)
 
 	var err error
diff --git a/node/node.go b/node/node.go
index 969452c4..c86efcf1 100644
--- a/node/node.go
+++ b/node/node.go
@@ -361,6 +361,9 @@ func NewNode(config *cfg.Config,
 		sm.BlockExecutorWithMetrics(smMetrics),
 	)
 
+	// set txIndexer
+	blockExec.SetTxIndexer(txIndexer)
+
 	// Make BlockchainReactor
 	bcReactor := bc.NewBlockchainReactor(state.Copy(), blockExec, blockStore, fastSync)
 	bcReactor.SetLogger(logger.With("module", "blockchain"))
diff --git a/state/execution.go b/state/execution.go
index 8ab95839..c44b1571 100644
--- a/state/execution.go
+++ b/state/execution.go
@@ -9,6 +9,8 @@ import (
 	"github.com/tendermint/tendermint/libs/fail"
 	"github.com/tendermint/tendermint/libs/log"
 	"github.com/tendermint/tendermint/proxy"
+	"github.com/tendermint/tendermint/state/txindex"
+	nulltxindexer "github.com/tendermint/tendermint/state/txindex/null"
 	"github.com/tendermint/tendermint/types"
 )
 
@@ -25,6 +27,9 @@ type BlockExecutor struct {
 	// execute the app against this
 	proxyApp proxy.AppConnConsensus
 
+	// indexer, null cacher if not set
+	txindexer txindex.TxIndexer
+
 	// events
 	eventBus types.BlockEventPublisher
 
@@ -50,13 +55,14 @@ func BlockExecutorWithMetrics(metrics *Metrics) BlockExecutorOption {
 // Call SetEventBus to provide one.
 func NewBlockExecutor(db dbm.DB, logger log.Logger, proxyApp proxy.AppConnConsensus, mempool Mempool, evpool EvidencePool, options ...BlockExecutorOption) *BlockExecutor {
 	res := &BlockExecutor{
-		db:       db,
-		proxyApp: proxyApp,
-		eventBus: types.NopEventBus{},
-		mempool:  mempool,
-		evpool:   evpool,
-		logger:   logger,
-		metrics:  NopMetrics(),
+		db:        db,
+		proxyApp:  proxyApp,
+		txindexer: &nulltxindexer.TxIndex{},
+		eventBus:  types.NopEventBus{},
+		mempool:   mempool,
+		evpool:    evpool,
+		logger:    logger,
+		metrics:   NopMetrics(),
 	}
 
 	for _, option := range options {
@@ -66,6 +72,11 @@ func NewBlockExecutor(db dbm.DB, logger log.Logger, proxyApp proxy.AppConnConsen
 	return res
 }
 
+// SetTxIndexer - sets tx indexer, if not called, nil, so
+func (blockExec *BlockExecutor) SetTxIndexer(indexer txindex.TxIndexer) {
+	blockExec.txindexer = indexer
+}
+
 // SetEventBus - sets the event bus for publishing block related events.
 // If not called, it defaults to types.NopEventBus.
 func (blockExec *BlockExecutor) SetEventBus(eventBus types.BlockEventPublisher) {
@@ -167,6 +178,16 @@ func (blockExec *BlockExecutor) ApplyBlock(state State, blockID types.BlockID, b
 
 	fail.Fail() // XXX
 
+	// cache txs first
+	for i, tx := range block.Data.Txs {
+		blockExec.txindexer.Cache(&types.TxResult{
+			Height: block.Height,
+			Index:  uint32(i),
+			Tx:     tx,
+			Result: *(abciResponses.DeliverTx[i]),
+		})
+	}
+
 	// Events are fired after everything else.
 	// NOTE: if we crash between Commit and Save, events wont be fired during replay
 	fireEvents(blockExec.logger, blockExec.eventBus, block, abciResponses, validatorUpdates)
diff --git a/state/txindex/indexer.go b/state/txindex/indexer.go
index ab509f96..c8aee640 100644
--- a/state/txindex/indexer.go
+++ b/state/txindex/indexer.go
@@ -9,6 +9,8 @@ import (
 
 // TxIndexer interface defines methods to index and search transactions.
 type TxIndexer interface {
+	// cache a result in memory, will be removed later if persisted in AddBatch.
+	Cache(result *types.TxResult)
 
 	// AddBatch analyzes, indexes and stores a batch of transactions.
 	AddBatch(b *Batch) error
diff --git a/state/txindex/kv/kv.go b/state/txindex/kv/kv.go
index 93249b7f..2195ec2c 100644
--- a/state/txindex/kv/kv.go
+++ b/state/txindex/kv/kv.go
@@ -7,11 +7,13 @@ import (
 	"sort"
 	"strconv"
 	"strings"
+	"sync"
 	"time"
 
 	"github.com/pkg/errors"
 	cmn "github.com/tendermint/tendermint/libs/common"
 	dbm "github.com/tendermint/tendermint/libs/db"
+	"github.com/tendermint/tendermint/libs/log"
 
 	"github.com/tendermint/tendermint/libs/pubsub/query"
 	"github.com/tendermint/tendermint/state/txindex"
@@ -20,6 +22,7 @@ import (
 
 const (
 	tagKeySeparator = "/"
+	cacheSizeMax    = 5000
 )
 
 var _ txindex.TxIndexer = (*TxIndex)(nil)
@@ -29,11 +32,16 @@ type TxIndex struct {
 	store        dbm.DB
 	tagsToIndex  []string
 	indexAllTags bool
+
+	logger   log.Logger
+	cache    map[string]types.TxResult
+	cacheMux sync.Mutex
 }
 
 // NewTxIndex creates new KV indexer.
 func NewTxIndex(store dbm.DB, options ...func(*TxIndex)) *TxIndex {
-	txi := &TxIndex{store: store, tagsToIndex: make([]string, 0), indexAllTags: false}
+	txi := &TxIndex{store: store, tagsToIndex: make([]string, 0), indexAllTags: false,
+		cache: make(map[string]types.TxResult)}
 	for _, o := range options {
 		o(txi)
 	}
@@ -54,6 +62,36 @@ func IndexAllTags() func(*TxIndex) {
 	}
 }
 
+func (txi *TxIndex) getFromCache(hash []byte) (types.TxResult, bool) {
+	txi.cacheMux.Lock()
+	defer txi.cacheMux.Unlock()
+	v, ok := txi.cache[string(hash)]
+	return v, ok
+}
+
+func (txi *TxIndex) removeFromCache(hash []byte) {
+	txi.cacheMux.Lock()
+	defer txi.cacheMux.Unlock()
+	delete(txi.cache, string(hash))
+}
+
+func (txi *TxIndex) Cache(result *types.TxResult) {
+	if result == nil {
+		return
+	}
+	txi.cacheMux.Lock()
+	defer txi.cacheMux.Unlock()
+	txi.cache[string(result.Tx.Hash())] = *result
+
+	if len(txi.cache) > cacheSizeMax {
+		if txi.logger != nil {
+			txi.logger.Error("TxIndexer cache size execeeds limit: %d", len(txi.cache))
+		} else {
+			fmt.Printf("TxIndexer cache size execeeds limit: %d\n", len(txi.cache))
+		}
+	}
+}
+
 // Get gets transaction from the TxIndex storage and returns it or nil if the
 // transaction is not found.
 func (txi *TxIndex) Get(hash []byte) (*types.TxResult, error) {
@@ -61,6 +99,10 @@ func (txi *TxIndex) Get(hash []byte) (*types.TxResult, error) {
 		return nil, txindex.ErrorEmptyHash
 	}
 
+	if v, ok := txi.getFromCache(hash); ok {
+		return &v, nil
+	}
+
 	rawBytes := txi.store.Get(hash)
 	if rawBytes == nil {
 		return nil, nil
@@ -103,6 +145,12 @@ func (txi *TxIndex) AddBatch(b *txindex.Batch) error {
 	}
 
 	storeBatch.Write()
+
+	// persisted, remove from cache
+	for _, result := range b.Ops {
+		txi.removeFromCache(result.Tx.Hash())
+	}
+
 	return nil
 }
 
diff --git a/state/txindex/null/null.go b/state/txindex/null/null.go
index f85de2e6..40c76be6 100644
--- a/state/txindex/null/null.go
+++ b/state/txindex/null/null.go
@@ -13,6 +13,9 @@ var _ txindex.TxIndexer = (*TxIndex)(nil)
 // TxIndex acts as a /dev/null.
 type TxIndex struct{}
 
+// Cache noop
+func (txi *TxIndex) Cache(result *types.TxResult) {}
+
 // Get on a TxIndex is disabled and panics when invoked.
 func (txi *TxIndex) Get(hash []byte) (*types.TxResult, error) {
 	return nil, errors.New(`Indexing is disabled (set 'tx_index = "kv"' in config)`)
